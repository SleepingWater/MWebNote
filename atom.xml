<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[学习笔记]]></title>
  <link href="https://sleepingwater.github.io/MWebNote/atom.xml" rel="self"/>
  <link href="https://sleepingwater.github.io/MWebNote/"/>
  <updated>2017-10-17T18:17:45+08:00</updated>
  <id>https://sleepingwater.github.io/MWebNote/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im">MWeb</generator>

  
  <entry>
    <title type="html"><![CDATA[第二章：词法作用域]]></title>
    <link href="https://sleepingwater.github.io/MWebNote/14978876951045.html"/>
    <updated>2017-06-19T23:54:55+08:00</updated>
    <id>https://sleepingwater.github.io/MWebNote/14978876951045.html</id>
    <content type="html"><![CDATA[
<p>1、词法阶段<br/>
* 作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的标识符，这叫做”遮蔽效应“。<br/>
* 全局变量会自动成为全局对象（比如浏览器中的window对象）的属性，因此可以不直接通过全局对象的此法名称，而是间接地通过对全局对象属性的引用来对齐进行访问。window.a 通过这种技术可以访问哪些被同名变量所遮蔽的全局变量。而非全局的变量如果被遮蔽了，就无法被访问到了。</p>

<p>2、欺骗词法<br/>
2.1、eval()</p>

<pre><code>function foo(str,a){
    eval(str);//欺骗！
    console.log(b,a);
}
var b=1;
foo(&quot;var b=3;&quot;,1);
</code></pre>

<p>2.2、with()</p>

<pre><code>function foo(obj){
    with(obj){
        a = 2;
    }
}
var o1 = {a:3};
var o2 = {b:3};
foo(o1);
console.log(o1.a);//2
foo(o2);
console.log(o2.a);//undefined
console.log(a);//2 a被泄露到全局作用域上了
</code></pre>

<p><strong>不推荐使用eval()和with</strong></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第三章：函数作用域和块作用域]]></title>
    <link href="https://sleepingwater.github.io/MWebNote/14978935513574.html"/>
    <updated>2017-06-20T01:32:31+08:00</updated>
    <id>https://sleepingwater.github.io/MWebNote/14978935513574.html</id>
    <content type="html"><![CDATA[
<ul>
<li>第三方库通常会在全局作用域中声明一个名字足够独特的变量，通常是一个对象。这个对象被用作库的命名空间。</li>
<li><p>函数表达式。</p>

<pre><code>var a = 2;
(function(def){
    def(window)
})(function def(global){
    var a = 3;
    console.log(a);//3
    console.log(global.a);//2
})  
</code></pre></li>
<li><p>块作用域</p>

<ol>
<li>with</li>
<li>try/catch</li>
<li>let</li>
<li>const</li>
</ol></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第四章：提升]]></title>
    <link href="https://sleepingwater.github.io/MWebNote/14979642997081.html"/>
    <updated>2017-06-20T21:11:39+08:00</updated>
    <id>https://sleepingwater.github.io/MWebNote/14979642997081.html</id>
    <content type="html"><![CDATA[
<ul>
<li>函数声明会被提升到普通变量之前</li>
<li>重复的var声明会被忽略，但出现在后面的函数声明还是可以覆盖前面的</li>
<li>IIFE（立即执行函数表达式）</li>
</ul>

<pre><code>(function sleep(x){
    console.log(&#39;I want &#39;+x);
})(&#39;sleep&#39;);
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第五章：作用域闭包]]></title>
    <link href="https://sleepingwater.github.io/MWebNote/14979651540114.html"/>
    <updated>2017-06-20T21:25:54+08:00</updated>
    <id>https://sleepingwater.github.io/MWebNote/14979651540114.html</id>
    <content type="html"><![CDATA[
<ul>
<li>对函数类型的值进行传递时，保留对它被声明的位置所处的作用域的引用。</li>
<li>只要使用了回调函数，实际上就是在使用闭包！so回调函数丢失外部函数调用对象</li>
</ul>

<pre><code>for (var i = 1; i &lt;= 5; i++) {
    setTimeout( function timer(){
        console.log(i);
    },i*1000);
}
//每隔1秒输出6
</code></pre>

<ul>
<li>块作用域。let劫持一个块儿并且就在这个块儿中声明一个变量，这实质上将块儿变成了一个我们可以闭包的作用域。</li>
<li>模块</li>
</ul>

<pre><code>function CoolModule(){
    var something = &quot;cool&quot;;
    var another = [1,2,3,4,5];
    function doSomething(){
        console.log(something);
    }
    function doAnother(){
        console.log(another.join(&quot;,&quot;));
    }
    return {
        doSomething:doSomething,
        doAnother:doAnother,
    };
}
var foo = CoolModule();
foo.doSomething();
foo.doAnother();
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第一章：关于this]]></title>
    <link href="https://sleepingwater.github.io/MWebNote/14980689294470.html"/>
    <updated>2017-06-22T02:15:29+08:00</updated>
    <id>https://sleepingwater.github.io/MWebNote/14980689294470.html</id>
    <content type="html"><![CDATA[
<ul>
<li>this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。</li>
</ul>

<h1 id="toc_0">第二章：this全面解析</h1>

<ol>
<li>默认绑定：纯粹的函数调用，this代表全局对象window。</li>
<li>隐示绑定：作为对象的方法调用，this代表上级对象。</li>
<li>显示绑定：apply() call()。</li>
<li>new绑定：作为构造函数调用，new一个全新的对象。</li>
</ol>

<p>ES6中的箭头函数，不适用于以上四种规则<br/>
<strong>优先级：new绑定 &gt; 显示绑定 &gt; 隐示绑定 &gt; 默认绑定</strong></p>

<h1 id="toc_1">关于apply() call()</h1>

<p>call和apply都是为了改变this而存在的，即改变函数内部的this指向。或者说改变某个函数运行时的上下文。<br/>
<strong>注：</strong>js的一个特点，函数存在【定义时上下文】【运行时上下文】以及【上下文是可以改变的】</p>

<p>一些常用用法（使用自己没有，但是别人有的方法）</p>

<ol>
<li>数组之间追加</li>
</ol>

<pre><code>var arr1 = [1,2,3];
var arr2 = [a,b,c];
Array.prototype.push.apply(arr1,arr2);
</code></pre>

<ol>
<li>获取数组中的最大值和最小值</li>
</ol>

<pre><code>var numbers = [11,23,13,4,9]
var maxNumber = Math.max.apply(Math,numbers);
</code></pre>

<ol>
<li>验证是否是数组</li>
</ol>

<pre><code>function isArray(obj){
    return object.prototype.toString().call(obj)===&quot;[object Array]&quot;
}
</code></pre>

<ol>
<li>类（伪）数组使用数组方法</li>
</ol>

<pre><code>var domNodes = Array.prototype.slice.apply(document.getElementsByTagName(&quot;*&quot;))
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于apply() call()]]></title>
    <link href="https://sleepingwater.github.io/MWebNote/14985664640586.html"/>
    <updated>2017-06-27T20:27:44+08:00</updated>
    <id>https://sleepingwater.github.io/MWebNote/14985664640586.html</id>
    <content type="html"><![CDATA[
<p>call和apply都是为了改变this而存在的，即改变函数内部的this指向。或者说改变某个函数运行时的上下文。<br/>
<strong>注：</strong>js的一个特点，函数存在【定义时上下文】【运行时上下文】以及【上下文是可以改变的】</p>

<p>一些常用用法（使用自己没有，但是别人有的方法）</p>

<ol>
<li>数组之间追加</li>
</ol>

<pre><code>var arr1 = [1,2,3];
var arr2 = [a,b,c];
Array.prototype.push.apply(arr1,arr2);
</code></pre>

<ol>
<li>获取数组中的最大值和最小值</li>
</ol>

<pre><code>var numbers = [11,23,13,4,9]
var maxNumber = Math.max.apply(Math,numbers);
</code></pre>

<ol>
<li>验证是否是数组</li>
</ol>

<pre><code>function isArray(obj){
    return object.prototype.toString().call(obj)===&quot;[object Array]&quot;
}
</code></pre>

<ol>
<li>类（伪）数组使用数组方法</li>
</ol>

<pre><code>var domNodes = Array.prototype.slice.apply(document.getElementsByTagName(&quot;*&quot;))
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[单例模式]]></title>
    <link href="https://sleepingwater.github.io/MWebNote/14996054012366.html"/>
    <updated>2017-07-09T21:03:21+08:00</updated>
    <id>https://sleepingwater.github.io/MWebNote/14996054012366.html</id>
    <content type="html"><![CDATA[
<p>把创建实例对象的职责和管理单利的职责分别放置在两个方法里，这两个方法可以独立变化而不影响，当它们连接在一起的时候，就完成了创建唯一实例对象的功能。</p>

<pre><code>var getSingle = function(fn){
    var result;//用变量resule来保存fn的计算结果。resule变量因为身在闭包中，它永远不会被销毁。在将来的请求中，如果result已经被赋值，那么它将返回这个值。
    return function(){
        return result || (result = fn.apply(this,arguments))
    }
}
var createDiv = function(){
    return &#39;abc&#39;;
}
var createSingleDiv = getSingle(createDiv);
var a = createSingleDiv();
var b = createSingleDiv();
a===b //true
</code></pre>

<h1 id="toc_0">策略模式</h1>

<p>定义一系列的算法，把它们一个个封装起来，并且使它们可以互相替换。</p>

<pre><code>var strategies = {
    &quot;S&quot;: function(salary){
        return salary*5;
    },
    &quot;A&quot;: function(salary){
        return salary*3;
    },
    &quot;B&quot;: function(salary){
    return salary;
    }
};
var calculateBonus = function(level,salary){
    return strategies[level](salary);
};
console.log(calculateBonus(&quot;S&quot;,2000));
console.log(calculateBonus(&quot;A&quot;,1000));
</code></pre>

<h1 id="toc_1">迭代器模式</h1>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Promise]]></title>
    <link href="https://sleepingwater.github.io/MWebNote/15021077667841.html"/>
    <updated>2017-08-07T20:09:26+08:00</updated>
    <id>https://sleepingwater.github.io/MWebNote/15021077667841.html</id>
    <content type="html"><![CDATA[
<p>promise的内容分为构造函数、实例方法和静态方法<br/>
* 1个构造函数：new Promise<br/>
* 2个实例方法：.then和.catch<br/>
* 4个静态方法：Promise.all、Promise.race(不常用)、Promise.resolve和Promise.reject</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第三章 Java的基本程序设计结构]]></title>
    <link href="https://sleepingwater.github.io/MWebNote/15066269056845.html"/>
    <updated>2017-09-29T03:28:25+08:00</updated>
    <id>https://sleepingwater.github.io/MWebNote/15066269056845.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">3.3 数量类型</h3>

<p>8种数据类型</p>

<ul>
<li>整型（int,short,long,type）</li>
<li>浮点型（float,double）</li>
<li>char类型</li>
<li>boolean型</li>
</ul>

<h3 id="toc_1">3.4 变量</h3>

<p>使用关键字final定义常量</p>

<h3 id="toc_2">3.5 运算符</h3>

<p>如果两个操作数中有一个是double类型，另一个操作数就会转换为double类型。<br/>
否则，如果其中一个操作数是float类型，另一个操作数就会转换为float类型。<br/>
否则，如果其中一个操作数是long类型，另一个操作数就会转换为long类型。<br/>
否则，两个操作数都将被转换为int类型</p>

<p>枚举类型</p>

<h3 id="toc_3">3.6 字符串</h3>

<p>3.6.5 空串和null</p>

<pre><code>//判断字符串不为空也不为null 
if(str != null &amp;&amp; str.length() != 0)    //*注意要先检查null
</code></pre>

<p>3.6.9 构建字符串<br/>
有些时候，需要由较短的字符串构建字符串，采购字符串连接的方式效率比较低。每次连接字符串，都会构建一个新的string对象，即耗时又浪费空间。这时候应该使用StringBuilder</p>

<pre><code>StringBuilder builder = new StringBuilder();
//每次需要添加一部分内容时就调用append
builder.append(ch);
builder.append(str);
//在需要构建字符串时就调用toString方法
String completeString = builder.toString();
</code></pre>

<p><mark><em>StringBuilder的前身是StringBuffer，其效率稍有点低，但是允许采用多线程的方式执行添加或删除字符串。如果所有字符串在一个线程中编辑，应该使用StringBuilder。</em></mark></p>

<h3 id="toc_4">3.7 输入输出</h3>

<p>3.7.1 输入<br/>
    构建一个Scanner对象</p>

<p>3.7.2 格式化输出<br/>
<img src="media/15066269056845/15066790016619.jpg" alt=""/></p>

<h3 id="toc_5">3.8 控制流程</h3>

<p>3.8.6 中断控制流程语句</p>

<ul>
<li>goto为java的保留字，但是不建议使用</li>
<li>不带标签的break</li>
<li>带标签的break（用于跳出多重嵌套的循环语句），用起来感觉和锚点有点像</li>
</ul>

<h3 id="toc_6">3.10 数组</h3>

<p>3.10.3 数组拷贝<br/>
    java中允许将一个数组变量拷贝给另一个数组变量。这时，两个变量将引用同一个数组。<br/>
    如果希望将一个数组的所有值拷贝到一个新的数组中去，就要使用Arrays类的copyTo方法。</p>

<p>3.10.4 命令行参数<br/>
    每一个Java应用程序都有一个带String arg[]参数的main方法。这个参数表明mian方法将接受一个字符串数组，也就是命令行参数。<br/>
    java Message hello world</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第一章：作用域是什么]]></title>
    <link href="https://sleepingwater.github.io/MWebNote/15066746963163.html"/>
    <updated>2017-09-29T16:44:56+08:00</updated>
    <id>https://sleepingwater.github.io/MWebNote/15066746963163.html</id>
    <content type="html"><![CDATA[
<p>1、编译原理</p>

<p>程序中的一段源代码执行之前会经历三个步骤</p>

<ol>
<li>分词/词法分析</li>
<li>解析/语法分析</li>
<li>代码生成</li>
</ol>

<p>对于JavaScript来说，大部分情况下编译发生在代码执行前的几微秒（甚至更短）</p>

<p>2、理解作用域</p>

<p>2.1、参与处理过程的演员们</p>

<ol>
<li>引擎</li>
<li>编译器</li>
<li>作用域</li>
</ol>

<p>2.2、对话</p>

<p>可以合理地假设编译器所产生的代码能够用下面的伪代码进行概括：”为一个变量分配内存，将其命名为a，然后将2保存进这个变量。“然后这并不完全正确。<br/>
事实上会进行如下操作<br/>
1. 遇到var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为a。<br/>
2. 在运行时引擎会在作用域中查找该变量，如果能找到就给它赋值。</p>

<p>2.3编译器有话说<br/>
LHS和RHS<br/>
异常：如果RHS没有找到某个变量会抛出异常，如果LHS没有找到某个变量，会创建一个该名称的变量。</p>

<p>3、作用域嵌套<br/>
当前作用域没有找到某个变量时，引擎会在外层嵌套的作用域中继续查找。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第四章 对象与类]]></title>
    <link href="https://sleepingwater.github.io/MWebNote/15066839297532.html"/>
    <updated>2017-09-29T19:18:49+08:00</updated>
    <id>https://sleepingwater.github.io/MWebNote/15066839297532.html</id>
    <content type="html"><![CDATA[
<p>一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。<br/>
可以显示地讲对象变量设置为null，表明这个对象变量目前没有引用任何对象。<br/>
如果将一个方法应用于一个值为null的对象上，就会产生错误。</p>

<pre><code>birthday = null;
String s = birthday.toString();//runtime error!
</code></pre>

<p>4.3.4 关于构造器</p>

<ul>
<li>构造器与类同名</li>
<li>每个类可以有一个以上的构造器</li>
<li>构造器可以有0个、1个或多个参数</li>
<li>构造器没有返回值</li>
<li>构造器总是伴随着new关键字调用</li>
</ul>

<p>4.3.5 隐示参数和显示参数<br/>
this表示隐示参数</p>

<h3 id="toc_0">4.4 静态域与静态方法</h3>

<p>4.4.1 静态域<br/>
这里给Employee类添加一个实例域id和静态域nextId</p>

<pre><code>class Employee{
    private static int nextId = 1;
    private int id;
    ...
}
</code></pre>

<p>如果有1000个Employee类的对象，则有1000个实例域id，但是只有一个静态域nextId。即使没有Employee类的对象，静态域nextId也存在，它属于类，不属于任何独立的对象。</p>

<p>4.4.2 静态常量<br/>
静态变量使用的较少，但静态常量使用的比较多。比如Math类中的PI</p>

<pre><code>public class Math{
    ...
    public static final double PI = 3.14159265388979323846;
    ...
}
</code></pre>

<p>4.4.3 静态方法<br/>
静态方法是一种不能向对象实施操作的方法。例如，Math类的pow方法就是一个静态方法。表达式<br/>
<code>Math.pow(x,a)</code>计算幂。在运算时，不适用任何Math对象。换句话说，没有隐式的参数this。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从数据结构及算法理论层面讨论MySQL数据库索引的数理基础]]></title>
    <link href="https://sleepingwater.github.io/MWebNote/15161190344824.html"/>
    <updated>2018-01-17T00:10:34+08:00</updated>
    <id>https://sleepingwater.github.io/MWebNote/15161190344824.html</id>
    <content type="html"><![CDATA[
<p>MySQL数据库支持多种索引类型，如BTree索引，哈希索引，全文索引等等。平常使用MySQL时主要打交道的索引是BTree索引。</p>

<h3 id="toc_0">1.索引的本质</h3>

<ul>
<li>MySQL官方对索引的定义为：<strong>索引（Index）是帮助MySQL高效获取数据的数据结构</strong>。</li>
<li>提取句子主干，就可以得到索引的本质：索引是数据结构。</li>
<li>查找算法：顺序查找、二分查找、二叉树查找等。但是每种查找算法都只能应用于特定的数据结构之上，例如二分查找要求被检索数据有序，而二叉树查找只能应用于二叉查找树上，但是数据本身的组织结构不可能完全满足各种数据结构。所以，<strong>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引</strong>。</li>
</ul>

<p><img src="media/15161190344824/15161201436062.jpg" alt=""/></p>

<h3 id="toc_1">2.B-Tree</h3>

<p><img src="media/15161190344824/15161202731296.jpg" alt=""/></p>

<p>由于B-Tree的特性，在B-Tree中按key检索数据的算法非常直观：首先从根节点进行二分查找，如果找到则返回对应节点的data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到null指针，前者查找成功，后者查找失败。</p>

<h3 id="toc_2">3.B+Tree</h3>

<p>与B-Tree相比，B+Tree有以下不同点：</p>

<ol>
<li>每个节点的指针上限为2d而不是2d+1。</li>
<li>内节点不存储data，只存储key；叶子节点不存储指针。</li>
</ol>

<p><img src="media/15161190344824/15161208157034.jpg" alt=""/></p>

<p>由于并不是所有节点都具有相同的域，因此B+Tree中叶节点和内节点一般大小不同。这点与B-Tree不同，虽然B-Tree中不同节点存放的key和指针可能数量不一致，但是每个节点的域和上限是一致的，所以在实现中B-Tree往往对每个节点申请同等大小的空间。<br/>
一般来说，B+Tree比B-Tree更适合实现外存储索引结构，具体原因与外存储器原理及计算机存取原理有关，将在下面讨论。</p>

<h3 id="toc_3">4.带有顺序访问指针的B+Tree</h3>

<p><img src="media/15161190344824/15161219444826.jpg" alt=""/></p>

<p>如图所示，在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。</p>

]]></content>
  </entry>
  
</feed>
