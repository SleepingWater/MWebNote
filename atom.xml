<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[MWeb学习笔记]]></title>
  <link href="https://sleepingwater.github.io/MWebNote/atom.xml" rel="self"/>
  <link href="https://sleepingwater.github.io/MWebNote/"/>
  <updated>2017-09-29T16:15:51+08:00</updated>
  <id>https://sleepingwater.github.io/MWebNote/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im">MWeb</generator>

  
  <entry>
    <title type="html"><![CDATA[第一章：作用域是什么&第二章：词法作用域]]></title>
    <link href="https://sleepingwater.github.io/MWebNote/14978876951045.html"/>
    <updated>2017-06-19T23:54:55+08:00</updated>
    <id>https://sleepingwater.github.io/MWebNote/14978876951045.html</id>
    <content type="html"><![CDATA[
<h1 id="toc_0">第一章：作用域是什么</h1>

<p>1、编译原理</p>

<p>程序中的一段源代码执行之前会经历三个步骤</p>

<ol>
<li>分词/词法分析</li>
<li>解析/语法分析</li>
<li>代码生成</li>
</ol>

<p>对于JavaScript来说，大部分情况下编译发生在代码执行前的几微秒（甚至更短）</p>

<p>2、理解作用域</p>

<p>2.1、参与处理过程的演员们</p>

<ol>
<li>引擎</li>
<li>编译器</li>
<li>作用域</li>
</ol>

<p>2.2、对话</p>

<p>可以合理地假设编译器所产生的代码能够用下面的伪代码进行概括：”为一个变量分配内存，将其命名为a，然后将2保存进这个变量。“然后这并不完全正确。<br/>
事实上会进行如下操作<br/>
1. 遇到var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为a。<br/>
2. 在运行时引擎会在作用域中查找该变量，如果能找到就给它赋值。</p>

<p>2.3编译器有话说<br/>
LHS和RHS<br/>
异常：如果RHS没有找到某个变量会抛出异常，如果LHS没有找到某个变量，会创建一个该名称的变量。</p>

<p>3、作用域嵌套<br/>
当前作用域没有找到某个变量时，引擎会在外层嵌套的作用域中继续查找。</p>

<h1 id="toc_1">第二章：词法作用域</h1>

<p>1、词法阶段<br/>
* 作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的标识符，这叫做”遮蔽效应“。<br/>
* 全局变量会自动成为全局对象（比如浏览器中的window对象）的属性，因此可以不直接通过全局对象的此法名称，而是间接地通过对全局对象属性的引用来对齐进行访问。window.a 通过这种技术可以访问哪些被同名变量所遮蔽的全局变量。而非全局的变量如果被遮蔽了，就无法被访问到了。</p>

<p>2、欺骗词法<br/>
2.1、eval()<br/>
<code><br/>
function foo(str,a){<br/>
    eval(str);//欺骗！<br/>
    console.log(b,a);<br/>
}<br/>
var b=1;<br/>
foo(&quot;var b=3;&quot;,1);<br/>
</code><br/>
2.2、with()<br/>
<code><br/>
function foo(obj){<br/>
    with(obj){<br/>
        a = 2;<br/>
    }<br/>
}<br/>
var o1 = {a:3};<br/>
var o2 = {b:3};<br/>
foo(o1);<br/>
console.log(o1.a);//2<br/>
foo(o2);<br/>
console.log(o2.a);//undefined<br/>
console.log(a);//2 a被泄露到全局作用域上了<br/>
</code></p>

<p><strong>不推荐使用eval()和with</strong></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第三章：函数作用域和块作用域]]></title>
    <link href="https://sleepingwater.github.io/MWebNote/14978935513574.html"/>
    <updated>2017-06-20T01:32:31+08:00</updated>
    <id>https://sleepingwater.github.io/MWebNote/14978935513574.html</id>
    <content type="html"><![CDATA[
<ul>
<li>第三方库通常会在全局作用域中声明一个名字足够独特的变量，通常是一个对象。这个对象被用作库的命名空间。</li>
<li><p>函数表达式。</p>

<pre><code>var a = 2;
(function(def){
    def(window)
})(function def(global){
    var a = 3;
    console.log(a);//3
    console.log(global.a);//2
})  
</code></pre></li>
<li><p>块作用域</p>

<ol>
<li>with</li>
<li>try/catch</li>
<li>let</li>
<li>const</li>
</ol></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第四章：提升]]></title>
    <link href="https://sleepingwater.github.io/MWebNote/14979642997081.html"/>
    <updated>2017-06-20T21:11:39+08:00</updated>
    <id>https://sleepingwater.github.io/MWebNote/14979642997081.html</id>
    <content type="html"><![CDATA[
<ul>
<li>函数声明会被提升到普通变量之前</li>
<li>重复的var声明会被忽略，但出现在后面的函数声明还是可以覆盖前面的</li>
<li>IIFE（立即执行函数表达式）</li>
</ul>

<pre><code>(function sleep(x){
    console.log(&#39;I want &#39;+x);
})(&#39;sleep&#39;);
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第五章：作用域闭包]]></title>
    <link href="https://sleepingwater.github.io/MWebNote/14979651540114.html"/>
    <updated>2017-06-20T21:25:54+08:00</updated>
    <id>https://sleepingwater.github.io/MWebNote/14979651540114.html</id>
    <content type="html"><![CDATA[
<ul>
<li>对函数类型的值进行传递时，保留对它被声明的位置所处的作用域的引用。</li>
<li>只要使用了回调函数，实际上就是在使用闭包！so回调函数丢失外部函数调用对象</li>
</ul>

<pre><code>for (var i = 1; i &lt;= 5; i++) {
    setTimeout( function timer(){
        console.log(i);
    },i*1000);
}
//每隔1秒输出6
</code></pre>

<ul>
<li>块作用域。let劫持一个块儿并且就在这个块儿中声明一个变量，这实质上将块儿变成了一个我们可以闭包的作用域。</li>
<li>模块</li>
</ul>

<pre><code>function CoolModule(){
    var something = &quot;cool&quot;;
    var another = [1,2,3,4,5];
    function doSomething(){
        console.log(something);
    }
    function doAnother(){
        console.log(another.join(&quot;,&quot;));
    }
    return {
        doSomething:doSomething,
        doAnother:doAnother,
    };
}
var foo = CoolModule();
foo.doSomething();
foo.doAnother();
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第一章：关于this]]></title>
    <link href="https://sleepingwater.github.io/MWebNote/14980689294470.html"/>
    <updated>2017-06-22T02:15:29+08:00</updated>
    <id>https://sleepingwater.github.io/MWebNote/14980689294470.html</id>
    <content type="html"><![CDATA[
<ul>
<li>this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。</li>
</ul>

<h1 id="toc_0">第二章：this全面解析</h1>

<ol>
<li>默认绑定：纯粹的函数调用，this代表全局对象window。</li>
<li>隐示绑定：作为对象的方法调用，this代表上级对象。</li>
<li>显示绑定：apply() call()。</li>
<li>new绑定：作为构造函数调用，new一个全新的对象。</li>
</ol>

<p>ES6中的箭头函数，不适用于以上四种规则<br/>
<strong>优先级：new绑定 &gt; 显示绑定 &gt; 隐示绑定 &gt; 默认绑定</strong></p>

<h1 id="toc_1">关于apply() call()</h1>

<p>call和apply都是为了改变this而存在的，即改变函数内部的this指向。或者说改变某个函数运行时的上下文。<br/>
<strong>注：</strong>js的一个特点，函数存在【定义时上下文】【运行时上下文】以及【上下文是可以改变的】</p>

<p>一些常用用法（使用自己没有，但是别人有的方法）</p>

<ol>
<li><p>数组之间追加<br/>
<code><br/>
var arr1 = [1,2,3];<br/>
var arr2 = [a,b,c];<br/>
Array.prototype.push.apply(arr1,arr2);<br/>
</code></p></li>
<li><p>获取数组中的最大值和最小值<br/>
<code><br/>
var numbers = [11,23,13,4,9]<br/>
var maxNumber = Math.max.apply(Math,numbers);<br/>
</code></p></li>
<li><p>验证是否是数组<br/>
<code><br/>
function isArray(obj){<br/>
return object.prototype.toString().call(obj)===&quot;[object Array]&quot;<br/>
}<br/>
</code></p></li>
<li><p>类（伪）数组使用数组方法<br/>
<code><br/>
var domNodes = Array.prototype.slice.apply(document.getElementsByTagName(&quot;*&quot;))<br/>
</code></p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于apply() call()]]></title>
    <link href="https://sleepingwater.github.io/MWebNote/14985664640586.html"/>
    <updated>2017-06-27T20:27:44+08:00</updated>
    <id>https://sleepingwater.github.io/MWebNote/14985664640586.html</id>
    <content type="html"><![CDATA[
<p>call和apply都是为了改变this而存在的，即改变函数内部的this指向。或者说改变某个函数运行时的上下文。<br/>
<strong>注：</strong>js的一个特点，函数存在【定义时上下文】【运行时上下文】以及【上下文是可以改变的】</p>

<p>一些常用用法（使用自己没有，但是别人有的方法）</p>

<ol>
<li><p>数组之间追加<br/>
<code><br/>
var arr1 = [1,2,3];<br/>
var arr2 = [a,b,c];<br/>
Array.prototype.push.apply(arr1,arr2);<br/>
</code></p></li>
<li><p>获取数组中的最大值和最小值<br/>
<code><br/>
var numbers = [11,23,13,4,9]<br/>
var maxNumber = Math.max.apply(Math,numbers);<br/>
</code></p></li>
<li><p>验证是否是数组<br/>
<code><br/>
function isArray(obj){<br/>
return object.prototype.toString().call(obj)===&quot;[object Array]&quot;<br/>
}<br/>
</code></p></li>
<li><p>类（伪）数组使用数组方法<br/>
<code><br/>
var domNodes = Array.prototype.slice.apply(document.getElementsByTagName(&quot;*&quot;))<br/>
</code></p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[单例模式]]></title>
    <link href="https://sleepingwater.github.io/MWebNote/14996054012366.html"/>
    <updated>2017-07-09T21:03:21+08:00</updated>
    <id>https://sleepingwater.github.io/MWebNote/14996054012366.html</id>
    <content type="html"><![CDATA[
<p>把创建实例对象的职责和管理单利的职责分别放置在两个方法里，这两个方法可以独立变化而不影响，当它们连接在一起的时候，就完成了创建唯一实例对象的功能。<br/>
<code><br/>
var getSingle = function(fn){<br/>
    var result;//用变量resule来保存fn的计算结果。resule变量因为身在闭包中，它永远不会被销毁。在将来的请求中，如果result已经被赋值，那么它将返回这个值。<br/>
    return function(){<br/>
        return result || (result = fn.apply(this,arguments))<br/>
    }<br/>
}<br/>
var createDiv = function(){<br/>
    return &#39;abc&#39;;<br/>
}<br/>
var createSingleDiv = getSingle(createDiv);<br/>
var a = createSingleDiv();<br/>
var b = createSingleDiv();<br/>
a===b //true<br/>
</code></p>

<h1 id="toc_0">策略模式</h1>

<p>定义一系列的算法，把它们一个个封装起来，并且使它们可以互相替换。<br/>
<code><br/>
var strategies = {<br/>
    &quot;S&quot;: function(salary){<br/>
        return salary*5;<br/>
    },<br/>
    &quot;A&quot;: function(salary){<br/>
        return salary*3;<br/>
    },<br/>
    &quot;B&quot;: function(salary){<br/>
    return salary;<br/>
    }<br/>
};<br/>
var calculateBonus = function(level,salary){<br/>
    return strategies[level](salary);<br/>
};<br/>
console.log(calculateBonus(&quot;S&quot;,2000));<br/>
console.log(calculateBonus(&quot;A&quot;,1000));<br/>
</code></p>

<h1 id="toc_1">迭代器模式</h1>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Promise]]></title>
    <link href="https://sleepingwater.github.io/MWebNote/15021077667841.html"/>
    <updated>2017-08-07T20:09:26+08:00</updated>
    <id>https://sleepingwater.github.io/MWebNote/15021077667841.html</id>
    <content type="html"><![CDATA[
<p>promise的内容分为构造函数、实例方法和静态方法<br/>
* 1个构造函数：new Promise<br/>
* 2个实例方法：.then和.catch<br/>
* 4个静态方法：Promise.all、Promise.race(不常用)、Promise.resolve和Promise.reject</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第三章]]></title>
    <link href="https://sleepingwater.github.io/MWebNote/15066269056845.html"/>
    <updated>2017-09-29T03:28:25+08:00</updated>
    <id>https://sleepingwater.github.io/MWebNote/15066269056845.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">3.3 数量类型</h3>

<p>8种数据类型</p>

<ul>
<li>整型（int,short,long,type）</li>
<li>浮点型（float,double）</li>
<li>char类型</li>
<li>boolean型</li>
</ul>

<h3 id="toc_1">3.4 变量</h3>

<p>使用关键字final定义常量</p>

<h3 id="toc_2">3.5 运算符</h3>

<p>如果两个操作数中有一个是double类型，另一个操作数就会转换为double类型。<br/>
否则，如果其中一个操作数是float类型，另一个操作数就会转换为float类型。<br/>
否则，如果其中一个操作数是long类型，另一个操作数就会转换为long类型。<br/>
否则，两个操作数都将被转换为int类型</p>

<p>枚举类型</p>

]]></content>
  </entry>
  
</feed>
